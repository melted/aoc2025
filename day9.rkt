#lang racket

(define input (file->lines "F:/Niklas/src/aoc2025/input/day9.txt"))

(define example (list "7,1" "11,1" "11,7" "9,7" "9,5" "2,5" "2,3" "7,3"))

(define (parse input)
  (define (parse-line s)
    (map string->number (string-split s ",")))
  (list->vector (map parse-line input)))

(define (rectangle p1 p2)
  (* (+ 1 (abs (- (car p1) (car p2))))
     (+ 1 (abs (- (cadr p1) (cadr p2))))))

(define (solve input)
  (define points (parse input))
  (define len (vector-length points))
  (for*/fold ((m 0))
             ((i (in-range len))
              (j (in-range (+ i 1) len)))
    (let ((candidate (rectangle (vector-ref points i)
                                (vector-ref points j))))
      (values (max candidate m)))))

(define (fillv p1 p2)
  (let ((start (min (cadr p1) (cadr p2)))
        (end  (max (cadr p1) (cadr p2))))
    (for/list ((i (in-inclusive-range start end)))
      (list (car p1) i))))

(define (fillh p1 p2)
  (let ((start (min (car p1) (car p2)))
        (end  (max (car p1) (car p2))))
    (for/list ((i (in-inclusive-range start end)))
      (list i (cadr p1)))))

(define (offset p dx dy)
  (list (+ (car p) dx) (+ (cadr p) dy)))

(define (solve2 input)
  (define points (parse input))
  (define size (vector-length points))
  (define border (mutable-set))
  (define corners (list->set (vector->list points)))
  (define (create-border)
    (for ((i (in-range size)))
      (let ((next (remainder (+ i 1) size)))
        (let ((a (vector-ref points i))
              (b (vector-ref points next)))
          (if (= (car a) (car b))
              (for-each (λ (p) (set-add! border p)) (fillv a b))
              (for-each (λ (p) (set-add! border p)) (fillh a b)))))))
  (define rectangles
    (for*/vector ((i (in-range size))
                  (j (in-range (+ i 1) size)))
      (vector (rectangle (vector-ref points i)
                         (vector-ref points j)) i j)))
  (define (valid? p1 p2)
    (let ((l (min (car p1) (car p2)))
          (r (max  (car p1) (car p2)))
          (t (min (cadr p1) (cadr p2)))
          (b (max (cadr p1) (cadr p2))))
      (not (for/or ((p border))
        (and (< l (car p) r) (< t (cadr p) b))))))
  (vector-sort! rectangles (λ (a b) (> (vector-ref a 0) (vector-ref b 0))))
  (create-border)
  (for/first ((r rectangles)
             #:when (valid? (vector-ref points (vector-ref r 1))
                     (vector-ref points (vector-ref r 2))))
      (vector-ref r 0)))

(solve example)
(solve input)

(solve2 example)
(solve2 input)
